import * as _clerk_types from '@clerk/types';
import { Clerk, InitialState, Without, ClerkOptions, ClientResource, SDKMetadata, MultiDomainAndOrProxy, DomainOrProxyUrl, LoadedClerk, SignInProps, SignUpProps, RedirectUrlProp, OrganizationCustomRoleKey, OrganizationCustomPermissionKey, CheckAuthorizationWithCustomPermissions, HandleOAuthCallbackParams } from '@clerk/types';
import React from 'react';

declare global {
    interface Window {
        __clerk_publishable_key?: string;
        __clerk_proxy_url?: Clerk['proxyUrl'];
        __clerk_domain?: Clerk['domain'];
    }
}
type IsomorphicClerkOptions = Without<ClerkOptions, 'isSatellite'> & {
    Clerk?: ClerkProp;
    clerkJSUrl?: string;
    clerkJSVariant?: 'headless' | '';
    clerkJSVersion?: string;
    sdkMetadata?: SDKMetadata;
    publishableKey: string;
} & MultiDomainAndOrProxy;
type ClerkProviderProps = IsomorphicClerkOptions & {
    children: React.ReactNode;
    initialState?: InitialState;
};
interface BrowserClerkConstructor {
    new (publishableKey: string, options?: DomainOrProxyUrl): BrowserClerk;
}
interface HeadlessBrowserClerkConstructor {
    new (publishableKey: string, options?: DomainOrProxyUrl): HeadlessBrowserClerk;
}
type WithClerkProp<T = unknown> = T & {
    clerk: LoadedClerk;
};
interface HeadlessBrowserClerk extends Clerk {
    load: (opts?: Without<ClerkOptions, 'isSatellite'>) => Promise<void>;
    updateClient: (client: ClientResource) => void;
}
interface BrowserClerk extends HeadlessBrowserClerk {
    onComponentsReady: Promise<void>;
    components: any;
}
type ClerkProp = BrowserClerkConstructor | BrowserClerk | HeadlessBrowserClerk | HeadlessBrowserClerkConstructor | undefined | null;
type ButtonProps = {
    mode?: 'redirect' | 'modal';
    children?: React.ReactNode;
};
type SignInButtonProps = ButtonProps & Pick<SignInProps, 'fallbackRedirectUrl' | 'forceRedirectUrl' | 'signUpForceRedirectUrl' | 'signUpFallbackRedirectUrl'>;
type SignUpButtonProps = {
    unsafeMetadata?: SignUpUnsafeMetadata;
} & ButtonProps & Pick<SignUpProps, 'fallbackRedirectUrl' | 'forceRedirectUrl' | 'signInForceRedirectUrl' | 'signInFallbackRedirectUrl'>;
type SignInWithMetamaskButtonProps = ButtonProps & RedirectUrlProp;
type PageProps<T extends string> = {
    label: string;
    url: string;
    labelIcon: React.ReactNode;
} | {
    label: T;
    url?: never;
    labelIcon?: never;
};
type UserProfilePageProps = PageProps<'account' | 'security'>;
type UserProfileLinkProps = {
    url: string;
    label: string;
    labelIcon: React.ReactNode;
};
type OrganizationProfilePageProps = PageProps<'general' | 'members'>;
type OrganizationProfileLinkProps = UserProfileLinkProps;

declare const SignedIn: ({ children }: React.PropsWithChildren<unknown>) => JSX.Element | null;
declare const SignedOut: ({ children }: React.PropsWithChildren<unknown>) => JSX.Element | null;
declare const ClerkLoaded: ({ children }: React.PropsWithChildren<unknown>) => JSX.Element | null;
declare const ClerkLoading: ({ children }: React.PropsWithChildren<unknown>) => JSX.Element | null;
type ProtectProps = React.PropsWithChildren<({
    condition?: never;
    role: OrganizationCustomRoleKey;
    permission?: never;
} | {
    condition?: never;
    role?: never;
    permission: OrganizationCustomPermissionKey;
} | {
    condition: (has: CheckAuthorizationWithCustomPermissions) => boolean;
    role?: never;
    permission?: never;
} | {
    condition?: never;
    role?: never;
    permission?: never;
}) & {
    fallback?: React.ReactNode;
}>;
/**
 * Use `<Protect/>` in order to prevent unauthenticated or unauthorized users from accessing the children passed to the component.
 *
 * Examples:
 * ```
 * <Protect permission="a_permission_key" />
 * <Protect role="a_role_key" />
 * <Protect condition={(has) => has({permission:"a_permission_key"})} />
 * <Protect condition={(has) => has({role:"a_role_key"})} />
 * <Protect fallback={<p>Unauthorized</p>} />
 * ```
 */
declare const Protect: ({ children, fallback, ...restAuthorizedParams }: ProtectProps) => React.JSX.Element | null;
declare const RedirectToSignIn: {
    (props: _clerk_types.Without<WithClerkProp<_clerk_types.SignInRedirectOptions>, "clerk">): React.JSX.Element | null;
    displayName: string;
};
declare const RedirectToSignUp: {
    (props: _clerk_types.Without<WithClerkProp<_clerk_types.SignUpRedirectOptions>, "clerk">): React.JSX.Element | null;
    displayName: string;
};
declare const RedirectToUserProfile: {
    (props: _clerk_types.Without<{
        clerk: _clerk_types.LoadedClerk;
    }, "clerk">): React.JSX.Element | null;
    displayName: string;
};
declare const RedirectToOrganizationProfile: {
    (props: _clerk_types.Without<{
        clerk: _clerk_types.LoadedClerk;
    }, "clerk">): React.JSX.Element | null;
    displayName: string;
};
declare const RedirectToCreateOrganization: {
    (props: _clerk_types.Without<{
        clerk: _clerk_types.LoadedClerk;
    }, "clerk">): React.JSX.Element | null;
    displayName: string;
};
declare const AuthenticateWithRedirectCallback: {
    (props: _clerk_types.Without<WithClerkProp<HandleOAuthCallbackParams>, "clerk">): React.JSX.Element | null;
    displayName: string;
};
declare const MultisessionAppSupport: ({ children }: React.PropsWithChildren<unknown>) => JSX.Element;

export { AuthenticateWithRedirectCallback as A, type BrowserClerk as B, type ClerkProviderProps as C, type HeadlessBrowserClerk as H, type IsomorphicClerkOptions as I, MultisessionAppSupport as M, type OrganizationProfilePageProps as O, Protect as P, RedirectToSignIn as R, type SignInButtonProps as S, type UserProfilePageProps as U, type WithClerkProp as W, type UserProfileLinkProps as a, type OrganizationProfileLinkProps as b, type SignUpButtonProps as c, type SignInWithMetamaskButtonProps as d, type ClerkProp as e, ClerkLoaded as f, ClerkLoading as g, SignedOut as h, SignedIn as i, RedirectToSignUp as j, RedirectToUserProfile as k, RedirectToCreateOrganization as l, RedirectToOrganizationProfile as m, type ProtectProps as n };
